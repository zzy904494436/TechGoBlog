# JVM2-对象分配和垃圾回收

## 对象分配

new Object();

### 对象创建过程

类加载 ---> 检查加载 ---> 分配内存 ---> 内存空间初始化 ---> 设置 ---> 对象初始化

#### 检查加载 

A 在常量池 引用 B B还未加载：符号引用，符号：字面量   sun.misc.B 

直接引用---真实地址

检查加载时，符号引用--->直接引用

#### 分配内存

划分内存方式：指针碰撞（堆空间规整）或 空闲列表（堆空间不规整）

解决并发安全：**CAS**（比较并交换）、TLAB(Thread Local Allocation Buffer) （本地线程缓存）

#### 内存空间初始化

“零”值

#### 设置

对象

<img src="/Users/alex/Alex/everyday/TechGoBlog/source/img/JVM2_对象.png" alt="JVM2_对象" style="zoom:50%;" />

堆中 对象 的 类型指针 指向 方法区 的 类 

对象填充 凑整8字节的整数

#### 对象初始化

最后一步

---

### 对象的访问定位

#### 使用句柄

使用句柄池：

操作 对象 需要通过线程 虚拟机栈 ，如果操作是对象 本地变量表 refrence ---句柄池（堆） -----实例池（堆）

优点：更换对象时，句柄可以不换

缺点：二次转换，速度低

#### 直接指针（hotspot）

---

### 判断对象的存活

JVM、Java中，都是自动化的垃圾回收。

C === malloc free

C++ === new delete

Java === 自动 不用管 空间的释放

1. 引用计数法

   好处：简单

   缺点：两个对象互相引用（循环引用），都标记为1，可回收，但是不会回收( python VM中使用，Python额外线程特殊处理)

   JVM并没有采用，效率不高

2. 可达性分析（解决循环引用问题）

   GC Roots（RootSet） ： **静态变量** 、**线程栈变量** 、**常量池** 、**JNI**（指针）等等, 

   还有内部引用：class对象、异常对象，类加载器；

   同步锁：synchronized对象；

   内部对象，JMXBean；

   临时对象：跨代引用。

   ##### Class对象是否可被回收，可以，5个条件都满足，比较苛刻

   1. new出的对象 都回收了
   2. 任何地方没有引用，包括反射

   3. 对应的类加载器也被回收掉
   4. 类 java.lang.class对象
   5. 参数控制

#### Finalize 不推荐使用 

筛选---拯救 

不会重复执行，优先级比较低

只能被JVM调用，另外一个线程专门处理 **链表**

---

### 引用

#### 强引用：不会被回收

#### 软引用Soft：有用非必须，系统发生OOM时，回收（图片缓存）

#### 弱引用Weak：只要垃圾回收，就回收

#### 虚引用Phantom：任何时间都有可能被回收

---

### 对象的分配策略

**几乎所有的对象都在堆中进行分配**---没100%

绝大多数代码 解释执行 

<img src="/Users/alex/Alex/everyday/TechGoBlog/source/img/JVM2-对象分配.png" alt="JVM2-对象分配" style="zoom:50%;" />

#### 逃逸分析

循环次数足够大，会逃逸分析，分配到栈---> **栈上分配**

#### 是否是大对象?

是的话，直接分配到老年代，同时满足 1-大于参数 2-ParNew和Serl两款垃圾回收器

#### 动态年龄判断 （age == 15 时 不一定回收）

设置年龄 不够灵活，过早进入老年代，老年代太多了；太晚了，不进入老年代，新生代太多了，所以需要**动态年龄判断**

Eden、From、To、Tenured

#### 空间分配担保

JVM分析，统计历次老年代回收（每次释放10M空间），晋级对象只有8M，空间分配担保。

---

## 分代回收理论

### 什么是GC？

### GC分类

### 分代回收理论

Eden：From：To   8：1：1		Tenured												方法区

MinorGC/YoungGC   					MajorGC/Old GC 

​							FullGC

<img src="/Users/alex/Desktop/JVM2-GC.png" alt="JVM2-GC" style="zoom:50%;" />

#### 1. 复制算法

**优点：**实现简单，运行高效；没有内存碎片；**缺点：**空间利用率只有一半

##### Appel算法：加强版的复制算法 ---Eden的来源

8:1:1 90%以上对象都是垃圾 才分代  

提高空间利用率 90% 空间分配担保

#### 2.标记清除算法（老年代）

**优点：**线程不暂停；没有对象移动；**缺点：**位置不连续，产生碎片

#### 3.标记整理算法（老年代）

先标记 整理后 最后清除 

**优点：**没有内存碎片；**缺点：**指针需要移动

---

对象的移动 会耗时（实际地址的移动）；可达性分析效率很高，

整理总结图：

![JVM内存模型-King老师修改版本](/Users/alex/Alex/everyday/TechGoBlog/source/img/JVM内存模型-King老师修改版本.jpg)

---

下节 细讲**CMS** ，JVM调优，JDK发展

---

